<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Grobid\grobid-0.5.5\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.5" ident="GROBID" when="2019-09-05T11:21+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Neural Audio Synthesis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nal</forename><surname>Kalchbrenner</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erich</forename><surname>Elsen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karen</forename><surname>Simonyan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seb</forename><surname>Noury</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Norman</forename><surname>Casagrande</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Lockhart</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florian</forename><surname>Stimberg</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aäron</forename><surname>Van Den Oord</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sander</forename><surname>Dieleman</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koray</forename><surname>Kavukcuoglu</surname></persName>
						</author>
						<title level="a" type="main">Efficient Neural Audio Synthesis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract</head><p>Sequential models achieve state-of-the-art results in audio, visual and textual domains with respect to both estimating the data distribution and generating high-quality samples. Efficient sampling for this class of models has however remained an elusive problem. With a focus on text-to-speech synthesis, we describe a set of general techniques for reducing sampling time while maintaining high output quality. We first describe a single-layer recurrent neural network, the WaveRNN, with a dual softmax layer that matches the quality of the state-of-the-art WaveNet model. The compact form of the network makes it possible to generate 24 kHz 16-bit audio 4× faster than real time on a GPU. Second, we apply a weight pruning technique to reduce the number of weights in the WaveRNN. We find that, for a constant number of parameters, large sparse networks perform better than small dense networks and this relationship holds for sparsity levels beyond 96%. The small number of weights in a Sparse WaveRNN makes it possible to sample high-fidelity audio on a mobile CPU in real time. Finally, we propose a new generation scheme based on subscaling that folds a long sequence into a batch of shorter sequences and allows one to generate multiple samples at once. The Subscale WaveRNN produces 16 samples per step without loss of quality and offers an orthogonal method for increasing sampling efficiency.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Sequential generative models achieve state-of-the-art performance in a variety of domains including natural language <ref type="bibr" target="#b19">(Wu et al., 2016;</ref><ref type="bibr" target="#b17">Vaswani et al., 2017)</ref>, natural im-* Equal contribution 1 DeepMind 2 Google Brain. Correspondence to: Nal Kalchbrenner &lt;nalk@google.com&gt;.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proceedings of the 35</head><p>th International Conference on Machine Learning, <ref type="bibr">Stockholm, Sweden, PMLR 80, 2018</ref><ref type="bibr">. Copyright 2018</ref> by the author(s).</p><p>ages <ref type="bibr" target="#b15">(van den Oord et al., 2016b;</ref><ref type="bibr" target="#b13">Reed et al., 2017)</ref> and videos  and speech and music <ref type="bibr" target="#b15">(van den Oord et al., 2016a;</ref><ref type="bibr" target="#b10">Mehri et al., 2016;</ref><ref type="bibr" target="#b15">Simon &amp; Oore, 2017;</ref><ref type="bibr">Engel et al., 2017)</ref>. The models learn the joint probability of the data by factorizing the distribution into a product of conditional probabilities over each sample. This structure lets the models allot significant capacity to estimate each conditional factor, makes them robust during training and easy to evaluate. The ordering encoded in the structure also makes the sampling process strictly serial: a sample can be generated only after samples on which it depends have been produced in accordance with the ordering. The serial aspect of the sampling process can make it slow and impractical to use these models to generate high-dimensional data like speech and video.</p><p>Our goal is to increase the efficiency of sampling from sequential models without compromising their quality. The time T (u) that the sampling process takes is the product of the number of samples in the target u (e.g. the number of audio samples in a spoken utterance or the number of pixels in an image) and the time required to produce each sample. The latter can be decomposed into computation time c(op i ) and overhead d(op i ) for each of the N layers (operations) of the model:</p><formula xml:id="formula_0">T (u) = |u| N i=1 (c(op i ) + d(op i ))<label>(1)</label></formula><p>The value of T (u) can grow prohibitively large under any of the following conditions: if |u| is large as in the case of high-fidelity audio composed of 24,000 16-bit samples per second; if N is large due to the use of a very deep architecture such as WaveNet <ref type="bibr" target="#b15">(van den Oord et al., 2016a)</ref>; if c(op i ) is large due to e.g. especially wide layers or a large number of parameters; or if the overhead d(op i ) is high due to the cost of launching each individual operation.</p><p>With a focus on text-to-speech synthesis, we propose a set of methods to make sampling orders of magnitude faster. We reduce the contributions from each of the factors N , d(op i ), c(op i ), and |u| with minimal loss to the quality of the generated output. We benchmark all models on a single-speaker North-American English text-to-speech dataset where the input is composed of predicted linguistic feature vectors and the output is the raw 24 kHz, 16-bit waveform (Section 5). We report the Negative Log-Likelihood (NLL) reached by a model on held-out data, the results of A/B comparison tests between a pair of models as rated by human listeners and Mean Opinion Scores (MOS) for the samples of a model.</p><p>We begin by designing a sequence model that requires a low number N of operations per sample. We make use of the core property of recurrent neural networks (RNN) that a single recurrent layer applied to the previous state can deliver a highly non-linear transformation of the context. The WaveRNN model is a single-layer RNN with a dual softmax layer that is designed to efficiently predict 16-bit raw audio samples. We see that the WaveRNN with 896 units achieves NLL scores comparable to those of the largest WaveNet model, there is no significant difference in audio fidelity according to a A/B comparison test <ref type="table">(Table 1)</ref>, and the MOS is similarly high. The WaveRNN achieves this performance by requiring just N = 5 matrix-vector products in sequence for each 16-bit sample; for simplicity we exclude non-linearities and other minor operations from the count N . This is in contrast with WaveNet that has 30 residual blocks of two layers each requiring a series of N = 30 * 2 = 60 matrix-vector products.</p><p>Even with the low N , the overhead d(op i ) can still represent a significant bottleneck in a regular implementation of sampling from the WaveRNN. We sidestep the overhead by implementing custom GPU operations <ref type="bibr" target="#b1">(Diamos et al., 2016)</ref> for the sampling process. This allows the WaveRNN to generate 96,000 16-bit samples per second on a Nvidia P100 GPU, which corresponds to 4× real time of high-fidelity 24kHz 16-bit audio. As a comparison, our best GPU kernel for the WaveNet model runs at roughly 0.3× real time on the same platform. Throughput increases with a batch of 4 where the kernels achieve 39,0000 samples per second (a total throughput of 156,000 samples/sec.)</p><p>Reducing the number of parameters in the network decreases the amount of computation c(op i ) required for sampling. With that in mind, we aim at maximizing the performance we can get from a given amount of parameters. <ref type="bibr" target="#b4">(Gordon et al., 2017)</ref> also consider the problem of maximizing performance under a given compute budget and solve it with an approach based on neuron pruning. We sparsify the weights in the WaveRNN using the weight pruning techniques of <ref type="bibr" target="#b11">(Narang et al., 2017a;</ref><ref type="bibr" target="#b21">Zhu &amp; Gupta, 2017)</ref>. For a fixed parameter count, we discover that large sparse WaveRNNs significantly outperform small dense WaveRNNs and that this relationship holds up to high levels of sparsity greater than 96% <ref type="figure" target="#fig_0">(Figure 2</ref>).</p><p>The combination of Sparse WaveRNN's high quality output, its small number of parameters and the low requirements on memory bandwidth makes the model well-suited for efficient implementations on low-power mobile platforms <ref type="figure">Figure 1</ref>. The architecture of the WaveRNN with the dual softmax layer. c represents the coarse (high 8-bits) of the sample and f represents the fine (low 8-bits) of the sample. The multiplication by R happens for both the coarse and fine bits simultaneously, then output of the gates is evaluated for the coarse bits only and ct is sampled. Once ct has been sampled from P (ct), the gates are evaluated for the fine bits and ft is sampled.</p><formula xml:id="formula_1">c t f t 1 c t 1 P (c t ) P (f t ) h 2 h 2 R O 1 O 2 O 3 O 4 I</formula><p>(such as those found in mobile phones). We implement and benchmark the sparse matrix-vector products and nonlinearities used in the WaveRNN on a mobile CPU <ref type="table" target="#tab_2">(Table 2)</ref>. Even though the amounts of computation and memory bandwidth are, respectively, three and two orders of magnitude smaller on a mobile CPU than on a GPU, our benchmarks on off-the-shelf mobile CPUs indicate that the resources are sufficient for real-time on-device audio synthesis with a high-quality Sparse WaveRNN. To our knowledge, this is the first sequential neural model capable of real-time audio synthesis on a broad set of computing platforms including off-the-shelf mobile CPUs.</p><p>Finally, we tackle the contribution from the component |u| in Equation 1. Multiple recent approaches have the goal of making sampling from sequential models more parallel <ref type="bibr" target="#b13">(Reed et al., 2017;</ref><ref type="bibr" target="#b6">Gu et al., 2017;</ref><ref type="bibr" target="#b16">van den Oord et al., 2017)</ref>. However, these models either make local independence assumptions between generated samples undermining the backbone of sequential models, or they require training multiple domain-specific networks with specialized losses that restrict the overall usability of the models.</p><p>We propose a generation process based on subscaling. A tensor of scale L is folded into B sub-tensors of scale L/B. The B sub-tensors are generated in order, each conditioned on the previous sub-tensors. Subscaling lets us generate multiple samples at once in a batch. Since the conditioning of the generation of each sub-tensor on previous sub-tensors requires in practice only a relatively small future horizon, the generation of the next sub-tensor may start soon after the start of the generation for the previous sub-tensor. It is possible in principle -although not necessary in practiceto recover distant future and past dependencies beyond the horizon; the precise cost of batched sampling is then just the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Wave Recurrent Neural Networks</head><p>Convolutional sequence models <ref type="bibr" target="#b7">(Kalchbrenner et al., 2016)</ref> achieve excellent performance in speech synthesis ), yet their architecture tends to be deep and narrow requiring a long chain of layers to be executed for each sample. We seek an architecture that provides an equally expressive and non-linear transformation of the context, but requires a small number of operations at each step. By having a hidden state that maintains an already compressed representation of the context, an RNN is especially suitable for this purpose as it is able to combine the context with the input within a single transformation. The overall computation in the WaveRNN is as follows (we omit biases for brevity):</p><formula xml:id="formula_2">x t = [c t−1 , f t−1 , c t ] u t = σ(R u h t−1 + I u x t ) r t = σ(R r h t−1 + I r x t ) e t = τ (r t • (R e h t−1 ) + I e x t ) h t = u t • h t−1 + (1 − u t ) • e t (2) y c , y f = split(h t ) P (c t ) = softmax(O 2 relu(O 1 y c )) P (f t ) = softmax(O 4 relu(O 3 y f ))</formula><p>where the indicates a masked matrix whereby the last coarse input c t is only connected to the fine part of the states u t , r t , e t and h t and thus only affects the fine output y f . The coarse and fine parts c t and f t are encoded as scalars in <ref type="bibr">[0,</ref><ref type="bibr">255]</ref> and scaled to the interval [−1, 1]. The matrix R formed from the matrices R u , R r , R e is computed as a single matrix-vector product to produce the contributions to all three gates u t , r t and e t (a variant of the GRU cell as in <ref type="bibr" target="#b0">(Chung et al., 2014;</ref><ref type="bibr" target="#b2">Engel, 2016)</ref>.) σ and τ are the standard sigmoid and tanh non-linearities. A possible architectural variant is to have h t depend only on x t−1 and use a fully connected layer followed by summation or concatenation to condition f t on c t ; we found that this version required 20% more parameters and also performed 1-2 centi-nats worse.</p><p>We split the state of the RNN in two parts that predict respectively the 8 coarse (or more significant) bits c t and the 8 fine (or least significant) bits f t of the 16-bit audio sample ( <ref type="figure">Figure 1</ref>). Each part feeds into a softmax layer over the corresponding 8 bits and the prediction of the 8 fine bits is conditioned on the 8 coarse bits. The resulting Dual Softmax layer allows for efficient prediction of 16-bit samples using two small output spaces (2 8 values each) instead of a single large output space (with 2 16 values). <ref type="figure">Figure 1</ref> shows this visually. We note that it is possible to train with one softmax over all 2 16 values, but that in addition to requiring significantly more parameters, memory and compute, it consistently performs 1-2 centi-nats worse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">WaveRNN Sampling on GPU</head><p>The above architecture reduces the number of operations N that are needed for each step from N = 60 for WaveNet with the 16-bit Discretized Logistic Mixture (DLM) output <ref type="bibr" target="#b14">(Salimans et al., 2017)</ref> to N = 5 for the proposed WaveRNN with the dual softmax. Despite the reduced number of operations N , a regular implementation of WaveRNN sampling does not directly yield a real-time or faster synthesis. On a GPU the primary hindrance is not the raw FLOPs required for sampling; rather, the difficulties are twofold: limits on the memory bandwidth and the time that it takes to launch each of the N operations. Regarding the former, a WaveRNN with a state of 896 units (WaveRNN-896) has about 3M parameters. A regular implementation of sampling that calls each WaveRNN operation separately in sequence for each of the 24,000 samples loads all of the WaveRNN parameters from memory into the GPU registers during each step, totalling about 3e6 × 24e3 × 4 = 288 GBytes of required memory bandwidth. This is already more than a third of the memory bandwidth available in an Nvidia P100 GPU, giving by itself an upper bound of 3×   real time for a regular implementation of sampling.</p><p>The overhead of launching each operation separately on the GPU is even larger. While launching an operation on the GPU has a constant overhead of 5 microseconds, each step requires N = 5 such operations, which means the launch overhead alone induces an upper bound of 40,000 samples per second. For the WaveNet architecture, which requires (at least) N = 60 operations per sample, the launch overhead induces an upper bound of 3,300 samples per second. This is without considering the time spent on the actual computation of the operations. In practice a regular implementation of sampling in e.g. Tensorflow yields, respectively, about 1600 and 170 samples per second for WaveRNN-896 and for WaveNet.</p><p>We reduce both of these factors by implementing the sampling procedure directly as a single persistent GPU operation. The memory bandwidth bottleneck is avoided since the parameters are loaded only once into the GPU registers at the start of sampling and persist in the registers throughout the process. This is possible because the P100 GPU has 3.67M full-precision registers that suffice to store more than 7 million half-precision parameters, i.e. more than twice as many as needed in the WaveRNN-896. The operation launch bottleneck is also avoided, since the entire sampling process for an utterance is executed as a single GPU operation.</p><p>A state size of 896 is chosen specifically to fit the P100 GPU which has 56 multi-processors. The minimum numbers of warps that must be assigned to each multi-processor to access the full register file of the GPU is 8. If we assign each warp to a state calculation, then the state size must be a multiple of 56 * 8 = 448 and the largest multiple that fits in the available register space is 896.</p><p>The resulting GPU kernel for WaveRNN sampling is two orders of magnitude more efficient than the regular sampling implementation, reaching 96,000 samples/second for the WaveRNN-896. The corresponding operation for WaveNet reaches 8,000 samples/second. The new overhead d(op) is now given by the synchronization of the thousands of cores in the GPU <ref type="bibr" target="#b20">(Xiao &amp; c. Feng, 2010)</ref>, which takes just 500 nanoseconds per synchronization, instead of the 5 microseconds needed for each operation launch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Sparse WaveRNN</head><p>The WaveRNN architecture dramatically reduces the number of required operations N and implementing sampling as a single GPU operation eliminates much of the original computation c(op i ) and overhead d(op i ) bottlenecks. We next present a technique for reducing directly the amount of computation c(op i ) required by each operation. Decreasing the number of hidden units will reduce the amount of computation, but this comes with a significant loss in quality <ref type="table" target="#tab_4">(Table 3)</ref>. Instead, we reduce the number of non-zero weights in the network by sparsifying the weight matrices while retaining a large state size and respective representation capacity. This reduces c(op i ) since the number of non-zero weights is directly proportional to c(op i ) <ref type="table">(Table 4)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Weight Sparsification Method</head><p>We use a pruning scheme based on the weight magnitude that increases sparsity as training proceeds <ref type="bibr" target="#b11">(Narang et al., 2017a;</ref><ref type="bibr" target="#b21">Zhu &amp; Gupta, 2017)</ref>. We maintain a binary mask specifying the sparsity pattern of weight matrices. At the beginning of training, the weight matrices are dense. Every 500 steps, the weights within each sparsified layer are sorted by their magnitude and the mask is updated by zeroing out k weights with the smallest magnitude. The number k is computed as a fraction z of the total number of weights, which is gradually increased from 0 to the target sparsity Z  <ref type="figure">Figure 3</ref>. The dependency scheme of Subscale WaveRNN. Each box corresponds to one 16-bit sample. Subscaling first reshapes the tensor into B sub-tensors of interleaving samples. Then each sub-tensor is generated conditioned on past and future samples of previously generated sub-tensors; the past horizon is unbounded, whereas the future horizon of size F is tied to the receptive field of the conditioning network. Batched sampling can then be applied. The final tensor in the original scale is reconstituted from the generated sub-tensors.</p><p>as a function of the training step t:</p><formula xml:id="formula_3">z = Z 1 − 1 − t − t 0 S 3</formula><p>where t 0 is the step at which weight pruning begins and S is the total number of pruning steps. We use t 0 = 1000, S = 200k and train for a total of 500k steps for all models. Such a scheme is practical, easy to integrate into existing models, and does not increase the training time. We sparsify the three gate matrices within the GRU cell separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Structured Sparsity</head><p>We need to encode the sparsity mask in a manner that allows for efficient computation. The standard Compressed Sparse Row format uses about the same amount of storage for encoding the sparsity mask as it does for storing the parameters. Unlike hardware-oriented approaches such as Viterbi pruning <ref type="bibr" target="#b9">(Lee et al., 2018)</ref>, we explore structured sparsity as a means for reducing memory overhead. The structure in the sparsity mask that we consider is in the form of non-overlapping blocks of weights which are pruned or retained together based on the average magnitude of the weights within the block. We find that blocks of m = 16 weights lose little performance over unstructured sparsity while reducing the amount of memory needed for storing the sparsity pattern to 1 m of that required by an unstructured mask. Besides rectangular 4 × 4 blocks that we found to work well <ref type="bibr" target="#b5">(Gray et al., 2017;</ref><ref type="bibr" target="#b12">Narang et al., 2017b)</ref>, we also adopt blocks of shape m × 1 that induce an even lower memory bandwidth overhead. In the case of m × 1 blocks one only needs to retrieve a single activation value from the hidden state to perform the dot product. This is in contrast with the square blocks where for each block one needs to retrieve 4 activation values from the hidden state. We report results for both 16 × 1 and 4 × 4 blocks. The benchmarks confirm the greater speed of the 16 × 1 blocks <ref type="table">(Table 4)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Sparse WaveRNN Sampling on Mobile CPU</head><p>We take advantage of the low computation and memory bandwidth required by Sparse WaveRNN to implement matrix-vector operations necessary for sampling on mobile CPU. To maximize memory utilization, weights are stored in 16-bit floating point and converted to 32-bit floating point before being used in the computation. The activations and the calculations are kept in 32-bit floating point. The low memory overhead afforded by small blocks allows the sparse matrix-vector products to match the performance of dense matrix-vector products with the same parameter count. The number of sequential matrix-vector products per second is thus determined almost entirely by the number of parameters in the network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Subscale WaveRNN</head><p>We have described two ways of reducing sampling time in high-fidelity audio generation: the WaveRNN that reduces N and d(op) and the Sparse WaveRNN that reduces N and c(op). Lastly we reduce the contribution from the factor |u| in Equation 1. This factor depends on the size of the utterance u and a direct reduction of the size of u itself (such as going from 16 to 8 bits per sample) would negatively affect audio quality. Instead, we propose a method for generating a batch of B samples per step, instead of just one:</p><formula xml:id="formula_4">T (u) = |u| B N i=1 (c(op B i ) + d(op B i ))<label>(3)</label></formula><p>In many cases, the computation time for a batch of B examples, c(op</p><formula xml:id="formula_5">B i</formula><p>), grows sublinearly in the computation time of a single example c(op i ) because weights are reused and spare computational capacity is available. The ability to batch samples also makes it possible to generate across multiple processors and have a reduction in total sampling time that is linear in the number of processors.</p><p>Previous work on producing more than one sample per step in sequential models has required breaking local dependencies <ref type="bibr" target="#b13">(Reed et al., 2017)</ref>: two nearby samples that strongly depend on each other are produced independently, possibly conditioned on other samples. We introduce a general method that allows us to trade a small constant number of distant past and future dependencies for the ability to generate batches of B samples per step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Subscale Dependency Scheme</head><p>From the tensor u one first extracts a set of B sub-tensors that have a frequency or scale that is B times smaller. Each sub-tensor corresponds to a subscale slice of u (see <ref type="figure">Figure 3)</ref>. If u is a 24kHz audio utterance and B is 16, then each sub-tensor corresponds to a 24/16=1.5 kHz utterance. This is in contrast with a multi-scale scheme where the different subtensors extracted from u have increasing scales. Subscaling induces the following ordering on the dependencies of the variables in u, which is equivalent to the standard factorization of the joint:</p><formula xml:id="formula_6">P (u) = B s=0</formula><p>|u|/B i=0 P u Bi+s u Bj+s for j &lt; i, u Bk+z for z &lt; s and k ≥ 0</p><p>The sample u Bi+s for a given (i, s) depends on all samples u Bk+z for z &lt; s and k ≥ 0. Generation of u proceeds as follows: one first generates the first sub-tensor, then the second sub-tensor conditioned on the first one, then the third sub-tensor conditioned on the previous two, etc. The Subscale WaveRNN that generates a given sub-tensor is conditioned on the future context of previous sub-tensors using a masked dilated CNN with relus and the mask applied over past connections instead of future ones. Like the multiscale scheme, subscale schemes are equally applicable to multi-dimensional tensors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Batched Sampling</head><p>In contrast to the multi-scale scheme, subscaling makes it possible to generate B samples in a single step. In Equation 4, for values of k &gt; i + F for some future horizon F , the dependencies of u Bi+s on future samples u Bk+z with z &lt; s become overwhelmingly weak <ref type="figure">(Figure 3</ref>). The conditioning network itself in the Subscale WaveRNN only sees a finite and usually small number of future samples from the previous sub-tensors. The sampling of a sub-tensor can begin immediately after the first F samples of the previous sub-tensor have been generated. Because the Subscale WaveRNN is shared across all sub-tensors, it is possible to batch inputs and after B * F steps the total batch of the Subscale WaveRNN is B. Since the value of F (usually 64 or 128) is relatively small compared to the scale and length of u, even for relatively large values of B such as 16, the total lag of B * F steps remains negligible for the total sampling latency. Although the conditioning network needs to be executed for each batch of samples, computing the conditioning network doesn't affect the factor N of the Subscale WaveRNN because the network can be executed in parallel for a chosen number L of future samples. This increases the total sampling lag by B * L steps, which even for values of L = 100 remains negligible. Due to batched sampling even our regular implementation in Tensorflow achieves just about real-time speed (24,000 samples/second) for a Subscale WaveRNN 16× with 1024 hidden state units.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.">Recovering Future and Past Dependencies</head><p>Dropping distant future dependencies for k &gt; i + F allows us in principle also to recover an almost equal number of distant past dependencies. A sub-tensor z that succeeds the current sub-tensor s is (z − s)(F + 1) steps behind s, but leaves a trace of distant past samples. During training and sampling these distant past samples can be accessed to condition the generation of the current pass s. Analogously, a constant number of future distant samples beyond i + F from sub-tensors previous to s are also available for additional conditioning. The exact dependency scheme of using subscaling and batched sampling includes these distant dependencies; in practice, however, choosing a larger value F appears simpler than embedding the distant dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Fused Subscale WaveRNN</head><p>We use the scheme behind the Subscale WaveRNN to directly generate more than 16 bits per step in the WaveRNN itself. We take a Subscale WaveRNN 2× model and instead of batching the 2 sub-tensors we split the hidden state of the WaveRNN in two parts. We then use 8 softmaxes of 4 bits each and an F value of just two. The samples from the sub-tensors are given directly to the WaveRNN as input without using a conditioning network. The resulting Fused Subscale WaveRNN 2× achieves only a small drop in the quality of the output <ref type="table" target="#tab_4">(Table 3</ref>), but maps well onto the WaveRNN GPU custom operation. Compared to WaveRNN which runs at 4× real time, this model generates 32 bits per step and requires fewer synchronizations, resulting in a sampling speed of 10× real time. We note that in contrast to the Subscale WaveRNN, because fusion requires splitting the hidden state, audio quality drops quickly for factors beyond 2× in the Fused Subscale WaveRNN.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experiments</head><p>We perform experiments on the text-to-speech synthesis task and report the quality evaluation results as well as the sampling speed of our benchmarks on the corresponding platforms.</p><p>Text-to-speech models were trained on a dataset of 44 hours of North American English speech recorded by a professional speaker . The generation is conditioned on conventional linguistic features and predicted pitch information. All compared models synthesize raw audio at 24 kHz in 16-bit format. The evaluation is carried out on a held-out test set where we consider three performance measures: Negative Log-Likelihood of groundtruth audio; MOS between 1 (Bad) and 5 (Excellent) of generated speech utterances according to the subjective quality evaluation by human raters; and the results of direct A/B comparison tests between pairs of models as rated subjectively by humans on a scale between -3 (Much Worse Than) and +3 (Much Better Than).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">WaveRNN Quality Evaluation &amp; Speed</head><p>The WaveRNN models are trained on sequences of 960 audio samples of 16-bit each and full back-propagationthrough-time is applied to the models.  <ref type="table">Table 4</ref>. Performance of ARM matrix-vector multiplies (MVM) and respectively Gflops (GF) per second, using two big cores of each of the processors Snapdragon 808 and 835. For the dense 224 and 384 kernels, higher performance is possible (11.7 Gflops/sec and 16.3 Gflops/sec respectively) with custom layouts of the dense matrix, but this is best performance we could achieve with the standard row major layout.</p><p>WaveRNN-2048 also shows no significant differences.</p><p>The persistent GPU operations that we implement are most efficient for the WaveRNN-896 model, which achieves a NLL of 5.42 and a MOS value of 4.37 ± 0.073. Samples are generated at 96,000 samples per second for a batch size of 1 and 39,000 samples per second for a batch size of 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Sparse WaveRNN Quality Evaluation &amp; Speed</head><p>Figure 2 illustrates a core point about our investigation into sparse models. We use a dense WaveRNN model with a state size of 224 as a starting point because it is the largest that could be run on many current off the shelf mobile processors.</p><p>As a second baseline we use a model with a state size of 384 that we estimate to still be out of reach for even the fastest mobile platforms, as the model would require 30 GB/sec of memory bandwidth and no current mobile platform can provide this amount. <ref type="figure" target="#fig_0">Figure 2</ref> shows that if we fix the total parameter countand keep the corresponding sampling time also the samethen as we increase the degree of sparsity and the resulting size of layers, the fidelity of the models improves. This holds up to high degrees of sparsity &gt; 98%, where the state size h of the models reaches 2048 hidden units. Higher sparsity monotonically implies lower NLL and in fact higher sparsity levels have larger slopes. This suggests that for a given computational budget at inference time, it is much more efficient to use those parameters to sparsely connect a larger number of neurons in each layer.</p><p>In <ref type="table">Table 4</ref> and <ref type="figure" target="#fig_0">Figure 2</ref> we examine the impact of using block sparsity on NLL and speed, and find that 4 × 4 blocks generally yield the best NLL, but 16 × 1 blocks have a speed advantage. Surprisingly, both have better NLL than unstructured sparsity at low sparsity levels, but improve more slowly and eventually hit a minimum around 95% while unstructured sparsity continues to improve. We did not explore even higher levels of unstructured sparsity only because investigating extremely high levels of sparsity requires starting with extremely large dense layers making training computationally intensive. Unstructured sparsity is unsurprisingly slower during inference, but depending on the quality trade offs involved in using blocks (which will likely vary from model to model), it might still be preferred.</p><p>To obtain an estimate of Sparse WaveRNN sampling speed, we benchmarked all computationally heavy operations (sparse matrix-vector multiplication and softsign nonlinearity evaluations) required for producing each audio sample, and used these measurements to derive an estimate of the sampling speed. For example, a sample from a 1024 model requires 3 multiplications of 1024×1024 for the GRU gates, two multiplications of 512×512 for the projection, two multiplications of 512×256 for the logits and evaluating 3072 non-linearities. We add up the time for all of these operations to estimate the upper bound on sampling performance.</p><p>We perform our benchmarks on the Snapdragon 808 (SD 808) and Snapdragon 835 (SD 835) mobile CPUs, which are widely available in mobile phones. The two big cores of the SD 808 at 1.8GHz can do 28.8 Gflops/sec and the bandwidth out of the shared L2 cache is 14.4 GB/sec. The SD 835 is faster at 2.35GHz, with 2 cores able to do 37.6 Gflops/sec and pull 18.8 GB/sec from the cache. In practice, the achievable flops are often much lower (geekbench, a;b) and around 14.4 Gflops/sec and 28.2 Gflops/sec for SD 808 and 835 respectively. These numbers suggest that both our dense and sparse implementations are close to the maximum possible performance of the processor (the limiting factor for all kernels is bandwidth and not flops). For comparison, a modern Intel desktop CPU with AVX2 can do over 200 Gflops/sec and get over 200 GB/sec of bandwidth out of the L2 cache with only two cores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Subscale WaveRNN Quality Evaluation</head><p>The conditioning network of the Subscale WaveRNN is a masked dilated 1D CNN and has ten layers, convolutional kernels of size 3, 384 convolutional channels, and 768 residual channels.  <ref type="bibr">512 (60)</ref>. This is remarkable as audio generation with sequential models can be extremely sensitive to lost dependencies, especially local ones, and this quality result demonstrates the effectiveness of the subscale dependency scheme to preserve all the local dependencies that are the key to the high performance of sequential models.</p><p>The ability to batch computation by a factor of 8 or 16 yields a large amount of flexibility. Batching can increase throughput from a single GPU device increasing the overall sampling speed. In addition, it makes it possible to generate from multiple devices at once, where the generated bits are sent one-way and online from each device to the next. Such a setup gives in principle a linear speed-up over the sampling speed of a single device. If a single pass of Subscale WaveRNN with B = 16 runs at 4× real time on a GPU, then on a connected rack of 16 GPUs the Subscale WaveRNN 16× can in principle gain an equivalent linear speed-up for a total sampling speed of 4 * B = 64 times real time. Subscale WaveRNN can also be combined with Sparse WaveRNN and executed on a multi-core CPU gaining a speed-up proportional to the number of cores available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusion</head><p>We introduced the WaveRNN, a simple and powerful recurrent network for the sequential modeling of high fidelity audio, and we have demonstrated a high performance implementation of this model on GPUs. We have shown that large sparse models have much better quality than small dense models with the same number of parameters and we have written high performance block-sparse matrix-vector product operations to demonstrate that sampling time is proportional to parameter count. We then showed that high fidelity audio generation is now achievable on widely available low-power mobile CPUs. Finally, we introduced the subscale dependency scheme that lets sequential models generate many samples per step while preserving the output quality of the original model. The underlying ideas of the methods we introduce are not specific to audio, and the results of sparse models have implications for inference in all types of neural networks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. The Sparse WaveRNNs on each curve have the same number of parameters. The Sparse WaveRNNs with structured sparsity 16 × 1 and 4 × 4 hit a point of maximum performance at a high degree of sparsity. The points of maximum performance for the unstructured Sparse WaveRNNs fall beyond the tested range.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>SIZE SPARSITY % TYPE PLATFORM SAMPLES/SEC</figDesc><table>512 
95% 
4×4 
SD 835 
29,100 
512 
95% 
4×4 
SD 808 
19,800 
512 
95% 
16×1 
SD 835 
31,400 
512 
95% 
16×1 
SD 808 
21,600 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 2 .</head><label>2</label><figDesc>Benchmarks for Sparse WaveRNN Mobile sampling per- formance executed on the widely available Snapdragon 808 and 835 mobile CPUs. The model has 1024 hidden units, 95% sparsity and 4 × 4 structure sparsity. The benchmarks are based on running an equivalent computation on the mobile CPU including layers and softsign non-linearities (Section 5.2).</figDesc><table>0.0 
0.2 
0.4 
0.6 
0.8 
1.0 

Sparsity 

5.35 

5.40 

5.45 

5.50 

5.55 

5.60 

5.65 

NLL 

NLL vs. Sparsity for Constant Parameter Counts 

384 Equivalent 
224 Equivalent 
16x1 224 Equivalent 
4x4 224 Equivalent 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><head>Table 3 .</head><label>3</label><figDesc>WaveRNN NLL and MOS results on the text-to-speech benchmark. The Sparse WaveRNN Mobile model has 1024 hidden units with a 95.2% sparsity ratio and 4×4 blocks.</figDesc><table>MODEL 
NLL 
MOS 

WAVENET 
5.29 4.51 ± 0.08 

WAVERNN 224 
5.67 3.73 ± 0.09 
WAVERNN 384 
5.56 4.23 ± 0.09 
WAVERNN 896 
5.42 4.37 ± 0.07 
WAVERNN 2048 
5.33 4.46 ± 0.07 

SPARSE WR MOBILE 
5.52 4.33 ± 0.08 
SPARSE WR 224 / 1536@97.8% 5.48 4.39 ± 0.07 
SPARSE WR 384 / 2048@96.4% 5.42 4.48 ± 0.07 

SUBSCALE WR 1024 (16×) 
5.52 4.30 ± 0.08 
SUBSCALE WR 1024 (8×) 
5.46 4.39 ± 0.06 
FUSED SUBSCALE WR 896 (2×) 5.45 4.31 ± 0.08 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head></head><label></label><figDesc>The conditioning CNN has 5 stages of increas- ing dilation, for a total future horizon of F = 128 blocks of 8 or 16 samples each. The Subscale WaveRNNs that we evaluate have 1024 units in their hidden state. We do not use recoverable distant dependencies. We evaluate the model for two values of B, 8 and 16. The Subscale WaveRNN with B = 8 generates 8 16-bit samples at once at each step, which corresponds to a 3 kHz signal. As shown in Table 3, the Subscale WaveRNN 8× achieves a MOS of 4.39. This is equivalent to the MOS of the baseline WaveRNN-896 and it shows the ability of the Subscale WaveRNN 8× to accurately learn the distribution under the modified dependency scheme. We also evaluate a Subscale WaveRNN with B = 16, which generates an interleaving signal at 1.5 kHz. As shown in Table 1, the audio fidelity of the Subscale WaveRNN 16× is not significantly different from that of the WaveRNN-896 and, by transitivity, that of Wavenet</figDesc><table></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Empirical evaluation of gated recurrent neural networks on sequence modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ç</forename><surname>Gülçehre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<idno>abs/1412.3555</idno>
		<imprint>
			<date type="published" when="2014" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Persistent RNNs: Stashing recurrent weights on-chip</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Diamos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Catanzaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chrzanowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Coates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Elsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hannun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Satheesh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="2024" to="2033" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Optimizing RNNs with differentiable graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Engel</surname></persName>
		</author>
		<ptr target="https://svail.github.io/diff_graphs/" />
		<imprint>
			<date type="published" when="2016-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Neural audio synthesis of musical notes with wavenet autoencoders. CoRR, abs/1704.01279, 2017. geekbench</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Resnick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dieleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Norouzi</surname></persName>
		</author>
		<ptr target="https://browser" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Eban</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Nachum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Morphnet</surname></persName>
		</author>
		<title level="m">Fast &amp; Simple ResourceConstrained Structure Learning of Deep Networks</title>
		<imprint>
			<date type="published" when="2017-11" />
		</imprint>
	</monogr>
	<note>ArXiv e-prints</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Block-sparse gpu kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Radford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kingma</surname></persName>
		</author>
		<ptr target="https://blog.openai.com/block-sparse-gpu-kernels/" />
		<imprint>
			<date type="published" when="2017-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Non-autoregressive neural machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bradbury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">O K</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Socher</surname></persName>
		</author>
		<idno>abs/1711.02281</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Espeholt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Den Oord</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note>Neural machine translation in linear time. CoRR, abs/1610.10099</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Video pixel networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Den Oord</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Danihelka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="1771" to="1779" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Viterbi-based pruning for sparse matrix with fixed and high index compression ratio. ICLR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">I</forename><surname>Chuang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-J</forename><surname>Kim</surname></persName>
		</author>
		<ptr target="https://openreview.net/forum?id=S1D8MPxA-" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">SampleRNN: an unconditional end-to-end neural audio generation model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mehri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Gulrajani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sotelo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
		<idno>abs/1612.07837</idno>
		<imprint>
			<date type="published" when="2016" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Exploring sparsity in recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">E G F</forename><surname>Diamos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<idno>abs/1704.05119</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Blocksparse recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Undersander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">F</forename><surname>Diamos</surname></persName>
		</author>
		<idno>abs/1711.02782</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Parallel multiscale autoregressive density estimation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Den Oord</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Colmenarejo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Belov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="2912" to="2921" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Improving the pixelcnn with discretized logistic mixture likelihood and other modifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Salimans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Karpathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pixelcnn++</surname></persName>
		</author>
		<idno>abs/1701.05517</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pixel recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Oore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Performance</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rnn ; Van Den Oord</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dieleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Senior</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wavenet ; Van Den Oord</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<idno>abs/1609.03499</idno>
		<ptr target="https://magenta.tensorflow.org/performance-rnn" />
	</analytic>
	<monogr>
		<title level="m">Generating music with expressive timing and dynamics</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="1747" to="1756" />
		</imprint>
	</monogr>
	<note>A generative model for raw</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Den Oord</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Babuschkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Simonyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Van Den Driessche</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lockhart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Cobo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Stimberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Casagrande</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Grewe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Noury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dieleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Elsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Walters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Belov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hassabis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wavenet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note>Fast high-fidelity speech synthesis. CoRR, abs/1711.10433</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Parmar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">N</forename><surname>Gomez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Polosukhin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note>Attention is all you need. CoRR, abs/1706.03762</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Tacotron: A fully end-to-end text-to-speech synthesis model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Skerry-Ryan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stanton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Weiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Jaitly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Agiomyrgiannakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Saurous</surname></persName>
		</author>
		<idno>abs/1703.10135</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Google&apos;s neural machine translation system: Bridging the gap between human and machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">V</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Norouzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Macherey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Krikun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<idno>abs/1609.08144</idno>
		<imprint>
			<date type="published" when="2016" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Inter-block GPU communication via fast barrier synchronization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Feng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 IEEE International Symposium on Parallel Distributed Processing (IPDPS)</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">To prune, or not to prune: exploring the efficacy of pruning for model compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<idno>abs/1710.01878</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
